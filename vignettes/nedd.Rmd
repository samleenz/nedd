---
title: "nedd"
author: "Sam Lee"
date:  "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{nedd}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

set.seed(19384)
```

Welcome to our package, take a seat. Let me show you around. The purpose of this document is to give an overview of how to use the functions contained within `nedd` and also to highlight which other packages and functions we commonly use for our network analysis.

## Using `nedd`

```{r setup}
library(nedd)
library(tidyverse)
library(igraph)
```


### Protein interatction networks

Central to our network analysis methods are the protein protein interaction networks that provide us relation data about proteins. We've implemented three unweighted human PPI networks as `igraph` network objects. Node consitute proteins labelled with Uniprot IDs and edges are interactions between the proteins. 

```{r}
nedd::ascher_graph

nedd::huri_graph

nedd::STRING_graph
```

View the help pages of each of these for more details

## Other packages

Here be other packages and functions we may commonly want to use.

### Mapping between feature identifiers

The most consistent method I've found for mapping between feature identifiers is the `gprofiler2` package, which is part of the ELIXR infrastructure at EMBL. The webserver can be accessed at https://biit.cs.ut.ee/gprofiler/gost

ENSG ID to UNIPROT ID

```{r}
ensg <- c(
  "ENSG00000127080", "ENSG00000149930", "ENSG00000156711", "ENSG00000170464"
  )

uniprot <- gprofiler2::gconvert(ensg, target = "UNIPROTSWISSPROT") %>%
  dplyr::arrange(input_number)

uniprot

```

Sometines there is not a one to one mapping between naming standards. In this case the best option is to sort by `input_number`, then filter the table so there is one output per input number using `dplyr::distinct(input_number, .keep_all = TRUE)`. A `dplyr::{left,right}_join()` can then be used to drop entries in the input table that did not have a match in the target namespace. When converting from gene to protein mappings this will often occur for non-protein coding genes (rRNA, lncRNA, miRNA, pseudo-genes).

### Gene sets

THe package `msigdbr` provides a database of the MSigDB genesets for multiple species. These are good for gene-set enrichment testing.

Here I get the Notch signalling hallmark and convert the hgnc symbols to uniprot protein IDs. We will see this set of proteins again when looking at how PCSF works. 

```{r}
library(msigdbr)

notchSig <- msigdbr(category = "H") %>%
  dplyr::filter(gs_name == "HALLMARK_NOTCH_SIGNALING") %>% dplyr::pull(gene_symbol) %>%
  gprofiler2::gconvert(target = "UNIPROTSWISSPROT") %>%
  dplyr::arrange(input_number) %>%
  dplyr::distinct(input_number, .keep_all = TRUE) %>%
  dplyr::pull(target)

```


### Basic network analysis

`igraph` is the standard `R` library for analysis of network objects. The majority of straightforward analyses can be compelted with functions in this pacakge and it offers pretty powerful visualisations. The function names can be somewhat cryptic so this site is an invaluable resource https://igraph.org/r/doc/

```{r}


# create a random graph with 20 nodes, and P(edge) = 0.15
g <- sample_gnp(20, 0.15)
V(g)$name <- LETTERS[1:20]

g

plot(g)
```

#### Vertex analysis

```{r}
igraph:::V(g)

# subset a vertex sequence
igraph:::V(g)[c("C", "A", "T")]
```

#### Edge analysis

Vertices and edges can have attributes added to them, in effect these are *i* length vectors where *i* is `vcount(g)` or `ecount(g)` respectively. Common attributed include `c("name", "weight", "colour")`

```{r}

g <- set_edge_attr(g, "weight", value = sample(5, ecount(g), replace = TRUE))

E(g)$weight

```


#### Graph analysis

Find and colour all cliques within a graph 

```{r}

graph_clique <- igraph::cluster_optimal(g)

```

#### Graph visualisation

See https://igraph.org/r/doc/plot.common.html for a comprehensive list of `igraph` plotting parameters.

```{r}

# set vertex colour reflect node betweenness
vert_col <- nedd::makeContCol(g, nStatFunc = betweenness)

# set vertex size to reflect node degree
vert_size <- degree(g) %>%
  scales::rescale(to =  c(5, 15))



plot(
  g,
  vertex.color = vert_col,
  vertex.size = vert_size,
  vertex.label.color = "grey",
  vertex.label.family = "sans",
  edge.color = "purple",
  asp = 0 # changes the aspect ratio? i find 0 to almost always improve appearance
)

```

### Heat diffusion over a graph

`diffuStats` is a package for running heat diffusion and random walks on `igraph` networks

```{r}

# create a vector of scores to diffuse over our nodes
# sample from Bernoulli dist with P(success) = 0.25
scores <- matrix(
  rbinom(20, 1, 0.25),
  dimnames = list(LETTERS[1:20], "score"),
  ncol = 1
  )

l <- layout_nicely(g)

plot(g,
     vertex.size = ifelse(scores == 1, 10, 5),
     vertex.color = diffuStats::scores2colours(scores),
     vertex.label = scores,
     asp = 0,
     layout = l
     )

diffused <- diffuStats::diffuse(
  graph = g,
  method = "ber_p",
  scores = scores
  )

plot(g,
     vertex.size = ifelse(scores == 1, 10, 5),
     vertex.color = diffuStats::scores2colours(diffused),
     vertex.label = scores,
     asp = 0,
     layout = l
     )

```



### Prize collecting steiner forests

The prize collecitng steiner forest algorithm allows the joint analysis of node and edge weights to find optimal subgraphs under a single objective function. The `PCSF` package implements this in R and the package documentation does a good job of describing the method. The idea of PCSF is to find a set of trees within a graph that maximise the total node weight included in the trees will minimise the sum of the edge costs included. We will use the ascher graph as our background. While edge costs should have some relevant meaning for this example I will set all edge costs to random numbers in the range (0.1,0.5)

I will set the score of all proteins in the notch signalling geneset to 1.

```{r}
library(PCSF)

cost_graph <- set_edge_attr(ascher_graph, "weight", value = runif(ecount(ascher_graph), 0.1, 0.5))

prizes <- setNames(rep(1, length(notchSig)), notchSig)

pcsf_resutlts <- PCSF(cost)

```
